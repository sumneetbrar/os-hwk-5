#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random numbers from 0 to 99
 */
void mmm_init() {
	// malloc a size N array of pointers to doubles
	A = (double **) malloc(size * sizeof(double*));
	B = (double **) malloc(size * sizeof(double*));
	SEQ_MATRIX = (double **) malloc(size * sizeof(double*));
	PAR_MATRIX = (double **) malloc(size * sizeof(double*));

	 // iterate through each row and malloc a size N array of doubles
	for (int i = 0; i < size; i++) {
		A[i] = (double*) malloc(sizeof(double) * size);
		B[i] = (double*) malloc(sizeof(double) * size);
		SEQ_MATRIX[i] = (double*) malloc(sizeof(double) * size);
		PAR_MATRIX[i] = (double*) malloc(sizeof(double) * size);
	}

	srand((unsigned)time(NULL));	// seed the random number generator

 	// initialize A and B with random values between 0 and 99
	for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      A[i][j] = (double)(rand() % 100);
      B[i][j] = (double)(rand() % 100);
			SEQ_MATRIX[i][j] = 0;
      PAR_MATRIX[i][j] = 0;  
    }
	}
}

/**
 * Reset a given matrix to zeroes (their size is in the global var)
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      matrix[i][j] = 0;
    }
	}
}

/**
 * Free up memory allocated to all matrices
 * (their size is in the global var)
 */
void mmm_freeup() {
  // free each row
	for (int i = 0; i < size; i++) {
		free(A[i]);
		A[i] = NULL;  // dangling pointer

		free(B[i]);
		B[i] = NULL;

		free(SEQ_MATRIX[i]);
		SEQ_MATRIX[i] = NULL;

		free(PAR_MATRIX[i]);
		PAR_MATRIX[i] = NULL;
	}
	// free original array
	free(A);
	A = NULL;  // dangling pointer

	free(B);
	B = NULL;

	free(SEQ_MATRIX);
	SEQ_MATRIX = NULL;

	free(PAR_MATRIX);
	PAR_MATRIX = NULL;
}

/**
 * Sequential MMM (size is in the global var)
 */
void mmm_seq() {
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			for (int k = 0; k < size; k++) {
				SEQ_MATRIX[i][j] += A[i][k] * B[k][j];
			}
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args) {
	Threadz *content = (Threadz *) args;
	int startRow = content -> startRow;
	int endRow = content -> endRow;

	for (int i = startRow; i <= endRow; i++) {
		for (int j = 0; j < size; j++) {
			for (int k = 0; k < size; k++) {
				PAR_MATRIX[i][j] += A[i][k] * B[k][j];
			}
		}
	}
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
	double largestError = 0;

	for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
			double error = fabs(SEQ_MATRIX[i][j] - PAR_MATRIX[i][j]);
			if (error > largestError) largestError = error;
    }
	}
	return largestError;
}
